use std::time::Duration;
use std::net::SocketAddr;
use std::fs;

use axum::extract::State;
use axum::response::{IntoResponse, Json};
use axum::routing::get;
use axum::serve::Serve;
use axum::Router;
use hurl::util::logger::{LoggerOptionsBuilder, Verbosity};
use hurl::runner::{RunnerOptionsBuilder, Value};
use hurl_core::input::Input;
use tokio::net::TcpListener;
use tokio::task::spawn_blocking;
use serde_json::json;

use crate::app_build::axum_run;
use crate::utils::tests::*;
use crate::*;

#[axum::debug_handler]
async fn secrets_handler(State(state): State<AppState>) -> impl IntoResponse {
	let data = sqlx::query!("SELECT code FROM user_secrets WHERE code LIKE 'me_ll_%' ORDER BY created_at DESC LIMIT 1")
		.fetch_optional(&state.db)
		.await
		.unwrap()
		.map(|row| row.code);

	if let Some(code) = data {
		let login_link = format!("/login/{code}");
		eprintln!("Fixture server: Returning login link: {login_link}");
		login_link
	} else {
		eprintln!("Fixture server: No me_ll_ codes found");
		"/none".to_string()
	}
}

#[axum::debug_handler]
async fn webauthn_handler(State(_state): State<AppState>) -> impl IntoResponse {
	// Return test data for WebAuthn testing
	// In a real scenario, these would be generated by the browser's WebAuthn API
	Json(json!({
		"email": "valid@example.com",
		"name": "Test User",
		"credential": {
			"id": "test_credential_id",
			"rawId": "dGVzdF9jcmVkZW50aWFsX2lk",
			"response": {
				"attestationObject": "o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjESZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NBAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGdhdXRoRGF0YVjESZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NBAAAAAAAAAAAAAAAAAAAAAAAAAAAAEGZ1YmxpY1B1YmTLA2lkZW50aWZpZXJUeXBlA2lkZW50aWZpZXJUeXBlAwABZmxhZ3MFAGZhdXRoRGF0YVjESZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NBagBfCWdX4tA5Khq9QK-4w8y0mZ3m5pJ-3XnK",
				"clientDataJSON": "eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoidGVzdF9jaGFsbGVuZ2UiLCJvcmlnaW4ijoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwiY3Jvc3NPcmlnaW46ZmFsc2V9"
			},
			"type": "public-key",
			"clientExtensionResults": {}
		},
		"auth_response": {
			"id": "test_credential_id",
			"rawId": "dGVzdF9jcmVkZW50aWFsX2lk",
			"response": {
				"authenticatorData": "SzYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MBAAAAAQ",
				"clientDataJSON": "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoidGVzdF9jaGFsbGVuZ2UiLCJvcmlnaW4ijoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwiY3Jvc3NPcmlnaW46ZmFsc2V9",
				"signature": "MEUCIQCdwBCrP9gFLmfh6OGbg-qROlyyp4UuR1pD_6g0MqRFuAIgYxKp3t7Qn3gQ1L7aZ7jzQ3rO6sT9gW1x8K4fL0p5v0",
				"userHandle": "valid@example.com"
			},
			"type": "public-key",
			"clientExtensionResults": {}
		}
	}))
}

pub async fn app_server() -> (Serve<TcpListener, Router, Router>, SocketAddr, sqlx::SqlitePool) {
    Config::reload().await.unwrap();
	let config: Arc<ArcSwap<Config>> = Arc::new(ArcSwap::new(crate::CONFIG.read().await.clone()));
	let db = db_connect().await;

	let (addr, server) = axum_run(
		Some("127.0.0.1:0"),
		db.clone(),
		config.clone(),
		vec![],
		Some(|router| router
			.route("/secrets", get(secrets_handler))
			.route("/webauthn-fixture", get(webauthn_handler))
		),
	).await;

	let config_full = config.load_full();
	let mut config_mut = Arc::unwrap_or_clone(config_full);
	config_mut.external_url = format!("http://localhost:{}", addr.port());
	config.store(Arc::new(config_mut));

	(server, addr, db)
}

pub async fn run_test(hurl_path: &str) {
	eprintln!("\nRunning hurl test: {hurl_path}");

	eprintln!("Starting app server");

	let (server, addr, db) = app_server().await;
	let _server_handle = tokio::spawn(async move {
		server.await.unwrap();
	});
	let base_url = format!("http://127.0.0.1:{}", addr.port());
	let fixture_url = format!("{base_url}/secrets");
	let webauthn_fixture_url = format!("{base_url}/webauthn-fixture");

	// If this is omitted, the server will not start at all
	eprintln!("Waiting for server to be ready at {base_url}");
	let client = reqwest::Client::new();
	let resp = client.get(format!("{base_url}/login")).send().await.unwrap();
	assert_eq!(resp.status(), reqwest::StatusCode::OK);

	let content = fs::read_to_string(hurl_path)
		.unwrap_or_else(|e| panic!("Failed to read {hurl_path}: {e}"));

	let mut variables = hurl::runner::VariableSet::new();
	variables.insert("base_url".to_string(), Value::String(base_url));
	variables.insert("fixture_url".to_string(), Value::String(fixture_url.clone()));
	variables.insert("webauthn_fixture_url".to_string(), Value::String(webauthn_fixture_url.clone()));

	let hurl_input = Input::new(hurl_path);
	let runner_options = RunnerOptionsBuilder::new()
		.timeout(Duration::from_secs(2))
		.build();
	let logger_options = LoggerOptionsBuilder::new()
		.verbosity(Some(Verbosity::Verbose))
		.color(true)
		.build();
	
	let output = spawn_blocking(move || {
		eprintln!("Running hurl fr fr");
		hurl::runner::run(
			&content,
			Some(&hurl_input),
			&runner_options,
			&variables,
			&logger_options
		).unwrap()
	}).await.unwrap();

	// Dump user_secrets table for debugging
	eprintln!("\n=== Dumping user_secrets table ===");
	let secrets = sqlx::query!("SELECT code, user, metadata, expires_at, created_at FROM user_secrets ORDER BY created_at DESC")
		.fetch_all(&db)
		.await
		.unwrap_or_else(|e| {
			eprintln!("Failed to query user_secrets: {e}");
			Vec::new()
		});

	if secrets.is_empty() {
		eprintln!("No entries in user_secrets table");
	} else {
		eprintln!("Found {} entries in user_secrets table:", secrets.len());
		let nullstr = "<null>".to_string();
		for (i, secret) in secrets.iter().enumerate() {
			eprintln!("  {}:", i + 1);
			eprintln!("    code: {}", secret.code);
			eprintln!("    user: {}", secret.user);
			eprintln!("    metadata: {}", secret.metadata.as_ref().unwrap_or(&nullstr));
			eprintln!("    expires_at: {}", secret.expires_at);
			eprintln!("    created_at: {}", secret.created_at.unwrap_or_else(chrono::NaiveDateTime::default));
			eprintln!();
		}
	}
	eprintln!("=== End of user_secrets dump ===\n");

	assert!(output.errors().is_empty(), "Hurl did not succeed");
}
